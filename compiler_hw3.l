/* Definition section */
%{
#include "y.tab.h"	/* header file generated by bison */

extern YYSTYPE yylval; //YYSTYPE
char buf[256];
int scopeLevel;
int error;

/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
%}

/* Define regular expression label */
digit	[0-9]
letter	[a-zA-Z]
integer	{digit}+
float	{digit}+"."{digit}+
id	{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return ADD; }
"-"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return SUB; }
"*"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return MUL; }
"/"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return DIV; }
"%"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return MOD; }
"++"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return INC; }
"--"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return DEC; }

 /* Relational */
">"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return MT; }
"<"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return LT; }
">="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return MTE; }
"<="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return LTE; }
"=="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return EQ; }
"!="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return NE; }

 /* Assignment */
"="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return ASGN; }
"+="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return ADDASGN; }
"-="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return SUBASGN; }
"*="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return MULASGN; }
"/="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return DIVASGN; }
"%="			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return MODASGN; }

 /* Logical */
"&&"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return AND; }
"||"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return OR; }
"!"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return NOT; }

 /* Delimiters */
"("			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return LB; }
")"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return RB; }
"{"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); scopeLevel++; return LCB; }
"}"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); scopeLevel--; return RCB; }
"["			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return LSB; }
"]"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return RSB; }
","			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return COMMA; }

 /* Print Keywords */	
"print"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return PRINT; }

 /* Condition and Loop Keywords */
"if"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return IF; }
"else"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return ELSE; }
"for"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return FOR; }
"while"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); return WHILE; }

 /* Declaration Keywords */
"void"			{ strcat(buf, yytext); error = 0; printf("%s", yytext); yylval.string = strdup(yytext); return VOID; }
"int"			{ strcat(buf, yytext); error = 0; printf("%s", yytext); yylval.string = strdup(yytext); return INT; }
"float"  		{ strcat(buf, yytext); error = 0; printf("%s", yytext); yylval.string = strdup(yytext); return FLOAT; }
"string"  		{ strcat(buf, yytext); error = 0; printf("%s", yytext); yylval.string = strdup(yytext); return STRING; }
"bool"  		{ strcat(buf, yytext); error = 0; printf("%s", yytext); yylval.string = strdup(yytext); return BOOL; }

 /* boolean Keywords */
"true"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return TR; }
"false"     		{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return FA; }

"return"		{ strcat(buf, yytext); error = 0; printf("%s", yytext); yylval.string = strdup(yytext); return RET; }

 /* String Constant */
\"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); BEGIN STRING_STATE; }
<STRING_STATE>\"	{ strcat(buf, yytext); if(!error) printf("%s", yytext); BEGIN 0; }
<STRING_STATE>[^"]*	{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return S_CONST; }

 /* Number Constant */
{integer}		{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return I_CONST; }
{float}	    		{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return F_CONST; }

 /* C type Comment */
"/*"			{ strcat(buf, yytext); if(!error) printf("%s", yytext); BEGIN COMMENT; }
<COMMENT>[^*\n]+	{ strcat(buf, yytext); if(!error) printf("%s", yytext); }
<COMMENT>\n		{ printf("\n%d: ", yylineno); }
<COMMENT>"*"		{ strcat(buf, yytext); if(!error) printf("%s", yytext); }
<COMMENT>"*/"		{ strcat(buf, yytext); if(!error) printf("%s", yytext); BEGIN 0; }

 /* C++ type Comment */
\/\/.*			{ strcat(buf, yytext); if(!error) printf("%s", yytext); }

 /* Variable ID */
 {id}       		{ strcat(buf, yytext); if(!error) printf("%s", yytext); yylval.string = strdup(yytext); return ID; }

 /* others */

[;]			{ strcat(buf, yytext); if(!error) printf("%s", yytext); error = 0; return SEMICOLON; }
[\n]			{ strcpy(buf, "\0"); printf("\n%d: ", yylineno); }
[\t]			{ strcat(buf, yytext); printf("%s", yytext); } 			/* Ignore */
[^\t\n]			{ strcat(buf, yytext); printf("%s", yytext); } 			/* Ignore other charactor sets */
<<EOF>>			{ printf("\b"); return 0; }

%%

int yywrap()
{
    return 1;
}
